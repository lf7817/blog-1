<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>update和patch | 汪图南</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/blog/icon.png">
    <meta name="description" content="汪图南的个人博客">
    <link rel="preload" href="/blog/assets/css/0.styles.8da91f97.css" as="style"><link rel="preload" href="/blog/assets/js/app.9cb610bb.js" as="script"><link rel="preload" href="/blog/assets/js/6.a1c4f09e.js" as="script"><link rel="preload" href="/blog/assets/js/25.01885c22.js" as="script"><link rel="prefetch" href="/blog/assets/js/1.a2b4dfd1.js"><link rel="prefetch" href="/blog/assets/js/10.7a4c6dca.js"><link rel="prefetch" href="/blog/assets/js/11.f953c0b8.js"><link rel="prefetch" href="/blog/assets/js/12.136351da.js"><link rel="prefetch" href="/blog/assets/js/13.2a4bb4d6.js"><link rel="prefetch" href="/blog/assets/js/14.41ba71af.js"><link rel="prefetch" href="/blog/assets/js/15.cbb9dd1f.js"><link rel="prefetch" href="/blog/assets/js/16.a96ac543.js"><link rel="prefetch" href="/blog/assets/js/17.7fe139c5.js"><link rel="prefetch" href="/blog/assets/js/18.dc5d7bb4.js"><link rel="prefetch" href="/blog/assets/js/19.fd8e7faa.js"><link rel="prefetch" href="/blog/assets/js/2.1dc0e182.js"><link rel="prefetch" href="/blog/assets/js/20.f2536a36.js"><link rel="prefetch" href="/blog/assets/js/21.6969c9b6.js"><link rel="prefetch" href="/blog/assets/js/22.1fb20a9b.js"><link rel="prefetch" href="/blog/assets/js/23.f79f0f23.js"><link rel="prefetch" href="/blog/assets/js/24.1a9b4708.js"><link rel="prefetch" href="/blog/assets/js/26.b48d8b2f.js"><link rel="prefetch" href="/blog/assets/js/27.6f1f89e6.js"><link rel="prefetch" href="/blog/assets/js/28.7aec6ae5.js"><link rel="prefetch" href="/blog/assets/js/29.fcf20e25.js"><link rel="prefetch" href="/blog/assets/js/3.385378b9.js"><link rel="prefetch" href="/blog/assets/js/30.e805d02c.js"><link rel="prefetch" href="/blog/assets/js/31.67d25beb.js"><link rel="prefetch" href="/blog/assets/js/32.f85783d5.js"><link rel="prefetch" href="/blog/assets/js/33.2f84ef61.js"><link rel="prefetch" href="/blog/assets/js/34.38b4b85d.js"><link rel="prefetch" href="/blog/assets/js/35.8c328df4.js"><link rel="prefetch" href="/blog/assets/js/36.892eb439.js"><link rel="prefetch" href="/blog/assets/js/37.08c64c99.js"><link rel="prefetch" href="/blog/assets/js/38.e19be104.js"><link rel="prefetch" href="/blog/assets/js/39.296e34cf.js"><link rel="prefetch" href="/blog/assets/js/4.1d0e492b.js"><link rel="prefetch" href="/blog/assets/js/40.4d347511.js"><link rel="prefetch" href="/blog/assets/js/41.e4cc52a9.js"><link rel="prefetch" href="/blog/assets/js/42.93b0e25c.js"><link rel="prefetch" href="/blog/assets/js/43.31b05d6a.js"><link rel="prefetch" href="/blog/assets/js/44.afce4e23.js"><link rel="prefetch" href="/blog/assets/js/45.12060cee.js"><link rel="prefetch" href="/blog/assets/js/46.6511e928.js"><link rel="prefetch" href="/blog/assets/js/47.b388172e.js"><link rel="prefetch" href="/blog/assets/js/48.bcd09a01.js"><link rel="prefetch" href="/blog/assets/js/49.f0a645b5.js"><link rel="prefetch" href="/blog/assets/js/50.384e4843.js"><link rel="prefetch" href="/blog/assets/js/51.f5d25926.js"><link rel="prefetch" href="/blog/assets/js/52.a7b3ba83.js"><link rel="prefetch" href="/blog/assets/js/53.c9456b3b.js"><link rel="prefetch" href="/blog/assets/js/54.93c13767.js"><link rel="prefetch" href="/blog/assets/js/55.29c6e147.js"><link rel="prefetch" href="/blog/assets/js/56.e14ce69c.js"><link rel="prefetch" href="/blog/assets/js/57.c26de914.js"><link rel="prefetch" href="/blog/assets/js/58.9c88fc07.js"><link rel="prefetch" href="/blog/assets/js/59.17ddfe95.js"><link rel="prefetch" href="/blog/assets/js/60.246e9eb1.js"><link rel="prefetch" href="/blog/assets/js/61.96e2bb6f.js"><link rel="prefetch" href="/blog/assets/js/62.6d8930f5.js"><link rel="prefetch" href="/blog/assets/js/63.fcafe7dc.js"><link rel="prefetch" href="/blog/assets/js/64.0b991ff7.js"><link rel="prefetch" href="/blog/assets/js/65.212943bc.js"><link rel="prefetch" href="/blog/assets/js/66.e8c50439.js"><link rel="prefetch" href="/blog/assets/js/67.ce25d6d3.js"><link rel="prefetch" href="/blog/assets/js/68.d2170203.js"><link rel="prefetch" href="/blog/assets/js/69.d30a5a8d.js"><link rel="prefetch" href="/blog/assets/js/7.a6b46352.js"><link rel="prefetch" href="/blog/assets/js/70.eb98a610.js"><link rel="prefetch" href="/blog/assets/js/71.66c8732c.js"><link rel="prefetch" href="/blog/assets/js/72.5df63977.js"><link rel="prefetch" href="/blog/assets/js/73.f987f4ed.js"><link rel="prefetch" href="/blog/assets/js/74.096217c2.js"><link rel="prefetch" href="/blog/assets/js/75.c281fcd3.js"><link rel="prefetch" href="/blog/assets/js/76.7e5a9d04.js"><link rel="prefetch" href="/blog/assets/js/77.dd1d8d38.js"><link rel="prefetch" href="/blog/assets/js/78.bb074452.js"><link rel="prefetch" href="/blog/assets/js/79.129ae85f.js"><link rel="prefetch" href="/blog/assets/js/8.bdbf62cf.js"><link rel="prefetch" href="/blog/assets/js/80.5c3c7d03.js"><link rel="prefetch" href="/blog/assets/js/81.4c6ce1a9.js"><link rel="prefetch" href="/blog/assets/js/82.508bc8fe.js"><link rel="prefetch" href="/blog/assets/js/83.35eb0074.js"><link rel="prefetch" href="/blog/assets/js/84.8452d1f7.js"><link rel="prefetch" href="/blog/assets/js/85.761944af.js"><link rel="prefetch" href="/blog/assets/js/86.edc1e35f.js"><link rel="prefetch" href="/blog/assets/js/87.d6207ed3.js"><link rel="prefetch" href="/blog/assets/js/88.6a7e68ee.js"><link rel="prefetch" href="/blog/assets/js/89.76cf25db.js"><link rel="prefetch" href="/blog/assets/js/9.89ac6be4.js"><link rel="prefetch" href="/blog/assets/js/90.43ad03fd.js"><link rel="prefetch" href="/blog/assets/js/91.40d45d7a.js"><link rel="prefetch" href="/blog/assets/js/92.de551180.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.8da91f97.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">汪图南</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/interview/" class="nav-link">
  前端面试之道
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端书籍" class="dropdown-title"><span class="title">前端书籍</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          JavaScript书籍
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/books/javascript/know-up.html" class="nav-link">
  你不知道的JavaScript(上)
</a></li><li class="dropdown-subitem"><a href="/blog/books/javascript/know-down.html" class="nav-link">
  你不知道的JavaScript(中下)
</a></li><li class="dropdown-subitem"><a href="/blog/books/javascript/red-book.html" class="nav-link">
  JavaScript高级程序设计
</a></li><li class="dropdown-subitem"><a href="/blog/books/javascript/algorithm.html" class="nav-link">
  JavaScript数据结构和算法
</a></li><li class="dropdown-subitem"><a href="/blog/designPattern/" class="nav-link">
  JavaScript设计模式与开发实践
</a></li><li class="dropdown-subitem"><a href="/blog/books/javascript/es6.html" class="nav-link">
  深入理解ES6
</a></li></ul></li><li class="dropdown-item"><h4>
          Git书籍
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/books/git/" class="nav-link">
  精通Git
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/blog/vueAnalysis/introduction/" class="nav-link">
  Vue源码分析
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="自动化测试" class="dropdown-title"><span class="title">自动化测试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/test/vueTest.html" class="nav-link">
  Vue应用测试
</a></li></ul></div></div><div class="nav-item"><a href="/blog/webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/blog/typescript/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/blog/vuepress/" class="nav-link">
  VuePress
</a></div> <a href="https://github.com/wangtunan/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/interview/" class="nav-link">
  前端面试之道
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端书籍" class="dropdown-title"><span class="title">前端书籍</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          JavaScript书籍
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/books/javascript/know-up.html" class="nav-link">
  你不知道的JavaScript(上)
</a></li><li class="dropdown-subitem"><a href="/blog/books/javascript/know-down.html" class="nav-link">
  你不知道的JavaScript(中下)
</a></li><li class="dropdown-subitem"><a href="/blog/books/javascript/red-book.html" class="nav-link">
  JavaScript高级程序设计
</a></li><li class="dropdown-subitem"><a href="/blog/books/javascript/algorithm.html" class="nav-link">
  JavaScript数据结构和算法
</a></li><li class="dropdown-subitem"><a href="/blog/designPattern/" class="nav-link">
  JavaScript设计模式与开发实践
</a></li><li class="dropdown-subitem"><a href="/blog/books/javascript/es6.html" class="nav-link">
  深入理解ES6
</a></li></ul></li><li class="dropdown-item"><h4>
          Git书籍
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/books/git/" class="nav-link">
  精通Git
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/blog/vueAnalysis/introduction/" class="nav-link">
  Vue源码分析
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="自动化测试" class="dropdown-title"><span class="title">自动化测试</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/test/vueTest.html" class="nav-link">
  Vue应用测试
</a></li></ul></div></div><div class="nav-item"><a href="/blog/webpack/" class="nav-link">
  Webpack
</a></div><div class="nav-item"><a href="/blog/typescript/" class="nav-link">
  TypeScript
</a></div><div class="nav-item"><a href="/blog/vuepress/" class="nav-link">
  VuePress
</a></div> <a href="https://github.com/wangtunan/blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    Github
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>介绍</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vueAnalysis/introduction/" class="sidebar-link">介绍和参考</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>源码目录设计和架构设计</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vueAnalysis/design/" class="sidebar-link">设计</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Rollup构建版本</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vueAnalysis/rollup/" class="sidebar-link">Rollup基础知识</a></li><li><a href="/blog/vueAnalysis/rollup/vue.html" class="sidebar-link">Vue中的Rollup构建</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>从入口到构造函数整体流程</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vueAnalysis/entry/" class="sidebar-link">整体流程</a></li><li><a href="/blog/vueAnalysis/entry/global.html" class="sidebar-link">initGlobalAPI流程</a></li><li><a href="/blog/vueAnalysis/entry/init.html" class="sidebar-link">initMixin流程</a></li><li><a href="/blog/vueAnalysis/entry/state.html" class="sidebar-link">stateMixin流程</a></li><li><a href="/blog/vueAnalysis/entry/events.html" class="sidebar-link">eventsMixin流程</a></li><li><a href="/blog/vueAnalysis/entry/lifecycle.html" class="sidebar-link">lifecycleMixin流程</a></li><li><a href="/blog/vueAnalysis/entry/render.html" class="sidebar-link">renderMixin流程</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>响应式原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vueAnalysis/reactive/" class="sidebar-link">介绍</a></li><li><a href="/blog/vueAnalysis/reactive/prepare.html" class="sidebar-link">前置核心概念</a></li><li><a href="/blog/vueAnalysis/reactive/props.html" class="sidebar-link">props处理</a></li><li><a href="/blog/vueAnalysis/reactive/methods.html" class="sidebar-link">methods处理</a></li><li><a href="/blog/vueAnalysis/reactive/data.html" class="sidebar-link">data处理</a></li><li><a href="/blog/vueAnalysis/reactive/computed.html" class="sidebar-link">computed处理</a></li><li><a href="/blog/vueAnalysis/reactive/watch.html" class="sidebar-link">watch处理</a></li><li><a href="/blog/vueAnalysis/reactive/reactive.html" class="sidebar-link">深入响应式原理</a></li><li><a href="/blog/vueAnalysis/reactive/dep.html" class="sidebar-link">依赖收集</a></li><li><a href="/blog/vueAnalysis/reactive/notify.html" class="sidebar-link">派发更新</a></li><li><a href="/blog/vueAnalysis/reactive/nexttick.html" class="sidebar-link">nextTick实现原理</a></li><li><a href="/blog/vueAnalysis/reactive/problem.html" class="sidebar-link">变化侦测注意事项</a></li><li><a href="/blog/vueAnalysis/reactive/api.html" class="sidebar-link">变化侦测API实现</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>虚拟DOM和VNode</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vueAnalysis/dom/" class="sidebar-link">虚拟DOM</a></li><li><a href="/blog/vueAnalysis/dom/vnode.html" class="sidebar-link">VNode介绍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>组件化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vueAnalysis/component/" aria-current="page" class="sidebar-link">组件化介绍</a></li><li><a href="/blog/vueAnalysis/component/mount.html" class="sidebar-link">$mount方法</a></li><li><a href="/blog/vueAnalysis/component/render.html" class="sidebar-link">render和renderProxy</a></li><li><a href="/blog/vueAnalysis/component/createElement.html" class="sidebar-link">createElement</a></li><li><a href="/blog/vueAnalysis/component/createComponent.html" class="sidebar-link">createComponent</a></li><li><a href="/blog/vueAnalysis/component/merge.html" class="sidebar-link">合并策略</a></li><li><a href="/blog/vueAnalysis/component/patch.html" aria-current="page" class="active sidebar-link">update和patch</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/vueAnalysis/component/patch.html#update" class="sidebar-link">update</a></li><li class="sidebar-sub-header"><a href="/blog/vueAnalysis/component/patch.html#patch" class="sidebar-link">patch</a></li></ul></li><li><a href="/blog/vueAnalysis/component/lifecycle.html" class="sidebar-link">组件生命周期</a></li><li><a href="/blog/vueAnalysis/component/register.html" class="sidebar-link">组件注册</a></li><li><a href="/blog/vueAnalysis/component/async.html" class="sidebar-link">异步组件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>编译原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vueAnalysis/compile/" class="sidebar-link">编译原理介绍</a></li><li><a href="/blog/vueAnalysis/compile/parse.html" class="sidebar-link">parse模板解析</a></li><li><a href="/blog/vueAnalysis/compile/optimize.html" class="sidebar-link">optimize优化</a></li><li><a href="/blog/vueAnalysis/compile/codegen.html" class="sidebar-link">codegen代码生成</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>扩展</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vueAnalysis/expand/" class="sidebar-link">扩展</a></li><li><a href="/blog/vueAnalysis/expand/directive.html" class="sidebar-link">directive指令</a></li><li><a href="/blog/vueAnalysis/expand/filter.html" class="sidebar-link">filter过滤器</a></li><li><a href="/blog/vueAnalysis/expand/vmodel.html" class="sidebar-link">v-model</a></li><li><a href="/blog/vueAnalysis/expand/event.html" class="sidebar-link">event事件处理</a></li><li><a href="/blog/vueAnalysis/expand/slot.html" class="sidebar-link">普通插槽和作用域插槽</a></li><li><a href="/blog/vueAnalysis/expand/components.html" class="sidebar-link">内置组件</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vue-Router</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vueAnalysis/router/" class="sidebar-link">Vue-Router介绍</a></li><li><a href="/blog/vueAnalysis/router/register.html" class="sidebar-link">路由注册</a></li><li><a href="/blog/vueAnalysis/router/matcher.html" class="sidebar-link">matcher介绍</a></li><li><a href="/blog/vueAnalysis/router/change.html" class="sidebar-link">路由切换</a></li><li><a href="/blog/vueAnalysis/router/components.html" class="sidebar-link">内置组件</a></li><li><a href="/blog/vueAnalysis/router/hooks.html" class="sidebar-link">路由hooks钩子函数</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Vuex</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/vueAnalysis/vuex/" class="sidebar-link">Vuex介绍</a></li><li><a href="/blog/vueAnalysis/vuex/init.html" class="sidebar-link">Vuex初始化</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="update和patch"><a href="#update和patch" class="header-anchor">#</a> update和patch</h1> <p>来回顾一下之前提到的<code>mountComponent</code>方法，它有这样一段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在之前的章节中，我们介绍了<code>_render</code>方法及其<code>createElement</code>和<code>createComponent</code>的逻辑，知道<code>_render</code>返回的是一个<code>VNode</code>树形结构。而<code>_update</code>方法的作用就是利用这个<code>VNode</code>树形结构，来生成真正<code>DOM</code>节点。</p> <p>这一章节，我们来分析一下<code>update</code>方法的实现以及其中<code>patch</code>的逻辑。</p> <h2 id="update"><a href="#update" class="header-anchor">#</a> update</h2> <p><code>_update</code>其实是一个内部私有方法，它的调用时机有两个：<strong>初始化挂载阶段</strong>和<strong>派发更新阶段</strong>，其代码是在<code>lifecycleMixin</code>方法中被定义的，如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">lifecycleMixin</span> <span class="token punctuation">(</span><span class="token parameter">Vue<span class="token operator">:</span> Class<span class="token operator">&lt;</span>Component<span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_update</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">vnode<span class="token operator">:</span> VNode<span class="token punctuation">,</span> hydrating<span class="token operator">?</span><span class="token operator">:</span> boolean</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> vm<span class="token operator">:</span> Component <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">const</span> prevEl <span class="token operator">=</span> vm<span class="token punctuation">.</span>$el
    <span class="token keyword">const</span> prevVnode <span class="token operator">=</span> vm<span class="token punctuation">.</span>_vnode
    <span class="token keyword">const</span> restoreActiveInstance <span class="token operator">=</span> <span class="token function">setActiveInstance</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
    vm<span class="token punctuation">.</span>_vnode <span class="token operator">=</span> vnode
    <span class="token comment">// Vue.prototype.__patch__ is injected in entry points</span>
    <span class="token comment">// based on the rendering backend used.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// initial render</span>
      vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token comment">/* removeOnly */</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// updates</span>
      vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>prevVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">restoreActiveInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">// update __vue__ reference</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevEl<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      prevEl<span class="token punctuation">.</span>__vue__ <span class="token operator">=</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span>$el<span class="token punctuation">.</span>__vue__ <span class="token operator">=</span> vm
    <span class="token punctuation">}</span>
    <span class="token comment">// if parent is an HOC, update its $el as well</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$vnode <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$parent <span class="token operator">&amp;&amp;</span> vm<span class="token punctuation">.</span>$vnode <span class="token operator">===</span> vm<span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>_vnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span>$el
    <span class="token punctuation">}</span>
    <span class="token comment">// updated hook is called by the scheduler to ensure that children are</span>
    <span class="token comment">// updated in a parent's updated hook.</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>_update</code>代码并不是很多，其核心就是调用<code>__patch__</code>方法。在介绍<code>__patch__</code>之前，为了更好的理解后续相关的逻辑，我们先介绍几个小的知识点。</p> <ul><li><code>activeInstance</code>：从命名可以看出来，它的意思是当前激活的实例对象。我们知道组件渲染是一个递归的过程，它会先从子节点开始渲染，等到所有子节点渲染完毕后，最后再渲染父级。那么在这种递归渲染的过程中，我们必须正确保证一对引用关系：当前渲染的组件实例以及其父级组件实例。<code>activeInstance</code>就是当前渲染的组件实例，它是一个模块变量：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">let</span> activeInstance<span class="token operator">:</span> any <span class="token operator">=</span> <span class="token keyword">null</span>
</code></pre></div><p>在<code>_update</code>方法中，它使用<code>setActiveInstance</code>来设置当前激活的实例，使用<code>restoreActiveInstance</code>来恢复，<code>setActiveInstance</code>方法定义如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> restoreActiveInstance <span class="token operator">=</span> <span class="token function">setActiveInstance</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">setActiveInstance</span><span class="token punctuation">(</span><span class="token parameter">vm<span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> prevActiveInstance <span class="token operator">=</span> activeInstance
  activeInstance <span class="token operator">=</span> vm
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    activeInstance <span class="token operator">=</span> prevActiveInstance
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以看到在<code>setActiveInstance</code>中，它首先定义了闭包变量保存了当前激活的实例，然后把<code>activeInstance</code>设置为当前的参数<code>vm</code>，最后返回了一个函数，这个函数的目的是用来恢复<code>activeInstance</code>到上一个，也就是调用<code>restoreActiveInstance</code>方法。</p> <p>既然当前渲染的实例以及解决了，那么我们来看一下父级在这个过程中是如何保证的。在<code>initLifecycle</code>的过程中，有这样一段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">initLifecycle</span> <span class="token punctuation">(</span><span class="token parameter">vm<span class="token operator">:</span> Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
  <span class="token keyword">let</span> parent <span class="token operator">=</span> options<span class="token punctuation">.</span>parent
  <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>options<span class="token punctuation">.</span>abstract<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>parent<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>abstract <span class="token operator">&amp;&amp;</span> parent<span class="token punctuation">.</span>$parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      parent <span class="token operator">=</span> parent<span class="token punctuation">.</span>$parent
    <span class="token punctuation">}</span>
    parent<span class="token punctuation">.</span>$children<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  vm<span class="token punctuation">.</span>$parent <span class="token operator">=</span> parent
  vm<span class="token punctuation">.</span>$root <span class="token operator">=</span> parent <span class="token operator">?</span> parent<span class="token punctuation">.</span>$root <span class="token operator">:</span> vm
  <span class="token comment">// ...省略代码</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在<code>initLifecycle</code>方法执行的过程中，通过<code>while</code>循环来保存<code>parent</code>和<code>children</code>父子关系，对于父级来说，<code>$children</code>中存储了它所有的子节点，对于<code>$children</code>来说，可以通过<code>vm.$parent</code>获取到它的父级。</p> <ul><li><code>_vnode和$vnode</code>：<code>_vnode</code>和<code>$vnode</code>也是一对父子关系，其中<code>_vnode</code>表示当前<code>VNode</code>节点，<code>$vnode</code>表示其父节点。我们来回顾一下<code>_render</code>方法，它有这样几段代码：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_render</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...省略代码</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> render<span class="token punctuation">,</span> _parentVnode <span class="token punctuation">}</span> <span class="token operator">=</span> vm<span class="token punctuation">.</span>$options
  vm<span class="token punctuation">.</span>$vnode <span class="token operator">=</span> _parentVnode
  <span class="token keyword">let</span> vnode
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    vnode <span class="token operator">=</span> <span class="token function">render</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_renderProxy<span class="token punctuation">,</span> vm<span class="token punctuation">.</span>$createElement<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  vnode<span class="token punctuation">.</span>parent <span class="token operator">=</span> _parentVnode
  <span class="token keyword">return</span> vnode
<span class="token punctuation">}</span>
</code></pre></div><p>在介绍完这两组对应关系后，我们来看一下最核心的<code>__patch__</code>方法的实现，这个方法是多平台公用方法，它在<code>src/platforms/web/runtime/index.js</code>和<code>src/platforms/weex/runtime/index.js</code>文件中都有定义，我们主要看第一种，其定义代码如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> patch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./patch'</span>
<span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__patch__ <span class="token operator">=</span> inBrowser <span class="token operator">?</span> patch <span class="token operator">:</span> noop
</code></pre></div><p>在以上代码中，它使用<code>inBrowser</code>判断了当前是否处于浏览器环境，如果是则赋值为<code>path</code>，否则就是<code>noop</code>空函数。这样判断是因为<code>Vue</code>还可以运行在<code>node</code>服务端。接下来，我们在<code>path.js</code>中看一下<code>path</code>方法是如何定义的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> nodeOps <span class="token keyword">from</span> <span class="token string">'web/runtime/node-ops'</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> createPatchFunction <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'core/vdom/patch'</span>
<span class="token keyword">import</span> baseModules <span class="token keyword">from</span> <span class="token string">'core/vdom/modules/index'</span>
<span class="token keyword">import</span> platformModules <span class="token keyword">from</span> <span class="token string">'web/runtime/modules/index'</span>

<span class="token keyword">const</span> modules <span class="token operator">=</span> platformModules<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>baseModules<span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> patch<span class="token operator">:</span> Function <span class="token operator">=</span> <span class="token function">createPatchFunction</span><span class="token punctuation">(</span><span class="token punctuation">{</span> nodeOps<span class="token punctuation">,</span> modules <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>在这里我们可以看到，<code>patch</code>赋值的是<code>createPatchFunction</code>方法的调用结果，我们先不看<code>createPatchFunction</code>是如何定义的，我们先看来一下它传递的参数。</p> <ul><li><code>nodeOps</code>: <code>nodeOps</code>是引入了<code>web/runtime/node-ops.js</code>文件中的内容，我们选取一部分来举例说明它到底是什么。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">createElement</span> <span class="token punctuation">(</span><span class="token parameter">tagName<span class="token operator">:</span> string<span class="token punctuation">,</span> vnode<span class="token operator">:</span> VNode</span><span class="token punctuation">)</span><span class="token operator">:</span> Element <span class="token punctuation">{</span>
  <span class="token keyword">const</span> elm <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tagName<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>tagName <span class="token operator">!==</span> <span class="token string">'select'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> elm
  <span class="token punctuation">}</span>
  <span class="token comment">// false or null will remove the attribute but undefined will not</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>data <span class="token operator">&amp;&amp;</span> vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>attrs <span class="token operator">&amp;&amp;</span> vnode<span class="token punctuation">.</span>data<span class="token punctuation">.</span>attrs<span class="token punctuation">.</span>multiple <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    elm<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">'multiple'</span><span class="token punctuation">,</span> <span class="token string">'multiple'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> elm
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">insertBefore</span> <span class="token punctuation">(</span><span class="token parameter">parentNode<span class="token operator">:</span> Node<span class="token punctuation">,</span> newNode<span class="token operator">:</span> Node<span class="token punctuation">,</span> referenceNode<span class="token operator">:</span> Node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  parentNode<span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span>newNode<span class="token punctuation">,</span> referenceNode<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">removeChild</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token operator">:</span> Node<span class="token punctuation">,</span> child<span class="token operator">:</span> Node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">appendChild</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token operator">:</span> Node<span class="token punctuation">,</span> child<span class="token operator">:</span> Node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  node<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们可以发现，<code>node-ops.js</code>文件中封装的方法，实际上就是对真实<code>DOM</code>操作的一层封装，传递<code>nodeOps</code>的目的是为了在虚拟<code>DOM</code>转成真实<code>DOM</code>节点的过程中提供便利。</p> <ul><li><code>modules</code>: <code>modules</code>是<code>platformModules</code>和<code>baseModules</code>两个数组合并的结果，其中<code>baseModules</code>是对模板标签上<code>ref</code>和<code>directives</code>各种操作的封装。<code>platformModules</code>是对模板标签上<code>class</code>、<code>style</code>、<code>attr</code>以及<code>events</code>等操作的封装。</li></ul> <p><strong>小结</strong>：</p> <ol><li>在<code>update</code>这一节，我们知道了首次渲染和派发更新渲染的<code>patch</code>是有一点差异的，其差异为首次渲染时提供的根节点是一个真实的<code>DOM</code>元素，在派发更新渲染时提供的是一个<code>VNode</code>，这里差异的逻辑是在下面这段代码中：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevVnode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// initial render</span>
  vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$el<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token comment">/* removeOnly */</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">// updates</span>
  vm<span class="token punctuation">.</span>$el <span class="token operator">=</span> vm<span class="token punctuation">.</span><span class="token function">__patch__</span><span class="token punctuation">(</span>prevVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>在父子组件递归渲染的时候，首先渲染子组件，子组件渲染完毕后才会去渲染父组件，在这个递归的过程中，<code>activeInstance</code>始终指向当前渲染的组件实例。同时根据父子组件递归渲染的顺序，我们可以知道父子组件关于<code>create</code>和<code>mount</code>两个生命周期的执行顺序：</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// parent beforeCreate</span>
<span class="token comment">// parent created</span>
<span class="token comment">// parent beforeMount</span>
<span class="token comment">// child beforeCreate</span>
<span class="token comment">// child created</span>
<span class="token comment">// child beforeMount</span>
<span class="token comment">// child mounted</span>
<span class="token comment">// parent mounted</span>
</code></pre></div><ol start="3"><li><code>render</code>函数执行会得到一个<code>VNode</code>的树形结构，<code>update</code>的作用就是把这个虚拟<code>DOM</code>节点树转换成真实的<code>DOM</code>节点树。因此结合前面介绍的所有内容，我们可以得到一个从实例初始化到最终渲染成真实<code>DOM</code>到视图的一个主线流程图。</li></ol> <div style="text-align:center;"><img src="/blog/assets/img/vue-process.9f257f78.png" alt="流程图"></div> <h2 id="patch"><a href="#patch" class="header-anchor">#</a> patch</h2> <p>在上一个章节，我们遗留了一个<code>createPatchFunction</code>方法还没有分析，在<code>patch</code>这个章节，我们主要任务就是弄清楚<code>createPatchFunction</code>的实现原理。</p> <p>因为在<code>v2.6.11</code>版本中，<code>createPatchFunction</code>方法代码非常多，因此我们采取分段来说明，建议一边看文章一边对照源码学习。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">11/6/2020, 3:20:02 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/vueAnalysis/component/merge.html" class="prev">
        合并策略
      </a></span> <span class="next"><a href="/blog/vueAnalysis/component/lifecycle.html">
        组件生命周期
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.9cb610bb.js" defer></script><script src="/blog/assets/js/6.a1c4f09e.js" defer></script><script src="/blog/assets/js/25.01885c22.js" defer></script>
  </body>
</html>
